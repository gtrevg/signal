{{define "header"}}package signal

// Code generated by go generate; DO NOT EDIT.
// This file was generated by robots at
// {{ .Timestamp }}

import "math"
{{end}}
{{define "signal"}}
// Put{{ .Name }} places signal buffer back to the pool. If a type of
// provided buffer isn't {{ .Name }} or its capacity doesn't equal
// allocator capacity, the function will panic.
func (p *Pool) Put{{ .Name }}(s {{ .Interface }}) {
	if p == nil {
		return
	}
	if _, ok := s.({{ .Name }}); !ok {
		panic("pool put {{ .Builtin }} invalid type")
	}
	mustSameCapacity(s.Capacity(), p.allocator.Capacity)
	p.{{ .Pool }}.Put(s.Slice(0, p.allocator.Length))
}

// Capacity returns capacity of a single channel.
func (s {{ .Name }}) Capacity() int {
	if s.channels == 0 {
		return 0
	}
	return cap(s.buffer) / int(s.channels)
}

// Length returns length of a single channel.
func (s {{ .Name }}) Length() int {
	if s.channels == 0 {
		return 0
	}
	return int(math.Ceil(float64(len(s.buffer)) / float64(s.channels)))
}

// Cap returns capacity of whole buffer.
func (s {{ .Name }}) Cap() int {
	return cap(s.buffer)
}

// Len returns length of whole buffer.
func (s {{ .Name }}) Len() int {
	return len(s.buffer)
}

// Sample returns signal value for provided channel and position.
func (s {{ .Name }}) Sample(pos int) {{ .SampleType }} {
	return {{ .SampleType }}(s.buffer[pos])
}

// Append appends [0:Length] samples from src to current buffer and returns new
// {{ .Interface }} buffer. Both buffers must have same number of channels and bit depth,
// otherwise function will panic. If current buffer doesn't have enough capacity,
// new buffer will be allocated with capacity of both sources.
func (s {{ .Name }}) Append(src {{ .Interface }}) {{ .Interface }} {
	mustSameChannels(s.Channels(), src.Channels())
	{{if eq .Interface "Signed" "Unsigned"}}mustSameBitDepth(s.BitDepth(), src.BitDepth()){{end}}
	if s.Cap() < s.Len()+src.Len() {
		// allocate and append buffer with cap of both sources capacity;
		s.buffer = append(make([]{{ .Builtin }}, 0, s.Cap()+src.Cap()), s.buffer...)
	}
	result := {{ .Interface }}(s)
	for pos := 0; pos < src.Len(); pos++ {
		result = result.AppendSample(src.Sample(pos))
	}
	return result
}

// Slice slices buffer with respect to channels.
func (s {{ .Name }}) Slice(start, end int) {{ .Interface }} {
	start = s.ChannelPos(0, start)
	end = s.ChannelPos(0, end)
	s.buffer = s.buffer[start:end]
	return s
}

// Read{{ .Name }} reads values from the buffer into provided slice.
func Read{{ .Name }}(src {{ .Interface }}, dst []{{ .Builtin }}) {
	length := min(src.Len(), len(dst))
	for pos := 0; pos < length; pos++ {
		dst[pos] = {{if eq .Interface "Floating"}}{{ .Builtin }}(src.Sample(pos)){{else}}{{ .Builtin }}({{ .MaxBitDepth }}.{{ .Interface }}Value(src.Sample(pos))){{end}}
	}
}

// ReadStriped{{ .Name }} reads values from the buffer into provided slice.
// The length of provided slice must be equal to the number of channels,
// otherwise function will panic. Nested slices can be nil, no values for
// that channel will be appended.
func ReadStriped{{ .Name }}(src {{ .Interface }}, dst [][]{{ .Builtin }}) {
	mustSameChannels(src.Channels(), len(dst))
	for channel := 0; channel < src.Channels(); channel++ {
		for pos := 0; pos < src.Length() && pos < len(dst[channel]); pos++ {
			dst[channel][pos] = {{if eq .Interface "Floating"}}{{ .Builtin }}(src.Sample(src.ChannelPos(channel, pos))){{else}}{{ .Builtin }}({{ .MaxBitDepth }}.{{ .Interface }}Value(src.Sample(src.ChannelPos(channel, pos)))){{end}}
		}
	}
}

// Write{{ .Name }} writes values from provided slice into the buffer.
func Write{{ .Name }}(src []{{ .Builtin }}, dst {{ .Interface }}) {{ .Interface }} {
	length := min(dst.Cap()-dst.Len(), len(src))
	for pos := 0; pos < length; pos++ {
		dst = dst.AppendSample({{ .SampleType }}(src[pos]))
	}
	return dst
}

// WriteStriped{{ .Name }} appends values from provided slice into the buffer.
// The length of provided slice must be equal to the number of channels,
// otherwise function will panic. Nested slices can be nil, zero values for
// those channels will be appended.
func WriteStriped{{ .Name }}(src [][]{{ .Builtin }}, dst {{ .Interface }}) {{ .Interface }} {
	mustSameChannels(dst.Channels(), len(src))
	var length int
	for i := range src {
		if len(src[i]) > length {
			length = len(src[i])
		}
	}
	length = min(length, dst.Capacity()-dst.Length())
	for pos := 0; pos < length; pos++ {
		for channel := 0; channel < dst.Channels(); channel++ {
			if pos < len(src[channel]) {
				dst = dst.AppendSample({{ .SampleType }}(src[channel][pos]))
			} else {
				dst = dst.AppendSample(0)
			}
		}
	}
	return dst
}{{end}}
