{{define "header"}}package signal

// Code generated by go generate; DO NOT EDIT.
// This file was generated by robots at
// {{ .Timestamp }}

import "math"
{{end}}
{{define "signal"}}
// Put{{ .Name }} places signal buffer back to the pool. If a type of
// provided buffer isn't {{ .Name }} or its capacity doesn't equal
// allocator capacity, the function will panic.
func (p *Pool) Put{{ .Name }}(s {{ .Interface }}) {
	if p == nil {
		return
	}
	if sig, ok := s.({{ .Name }}); ok {
		capacity := cap(sig.buffer)
		for i, buf := 0, sig.buffer[:capacity]; i < capacity; i++ {
			buf[i] = 0
		}
	} else {
		panic("pool put {{ .Builtin }} invalid type")
	}
	mustSameCapacity(s.Capacity(), p.allocator.Capacity)
	if s.Length() != p.allocator.Length {
		s = s.Slice(0, p.allocator.Length)
	}
	p.{{ .Pool }}.Put(s)
}

// Capacity returns capacity of a single channel.
func (s {{ .Name }}) Capacity() int {
	if s.channels == 0 {
		return 0
	}
	return cap(s.buffer) / int(s.channels)
}

// Length returns length of a single channel.
func (s {{ .Name }}) Length() int {
	if s.channels == 0 {
		return 0
	}
	return int(math.Ceil(float64(len(s.buffer)) / float64(s.channels)))
}

// Cap returns capacity of whole buffer.
func (s {{ .Name }}) Cap() int {
	return cap(s.buffer)
}

// Len returns length of whole buffer.
func (s {{ .Name }}) Len() int {
	return len(s.buffer)
}

// Sample returns signal value for provided channel and index.
func (s {{ .Name }}) Sample(i int) {{ .SampleType }} {
	return {{ .SampleType }}(s.buffer[i])
}

// Append appends [0:Length] samples from src to current buffer and returns
// new {{ .Interface }} buffer. Both buffers must have same number of channels and
// bit depth, otherwise function will panic.
func (s {{ .Name }}) Append(src {{ .Interface }}) {{ .Interface }} {
	mustSameChannels(s.Channels(), src.Channels()){{if ne .Interface "Floating"}}
	mustSameBitDepth(s.BitDepth(), src.BitDepth()){{end}}
	offset := s.Len()
	if s.Cap() < s.Len()+src.Len() {
		s.buffer = append(s.buffer, make([]{{ .Builtin }}, src.Len())...)
	} else {
		s.buffer = s.buffer[:s.Len()+src.Len()]
	}
	for i := 0; i < src.Len(); i++ {
		s.SetSample(i+offset, src.Sample(i))
	}
	alignCapacity(&s.buffer, s.Channels(), s.Cap())
	return s
}

// Slice slices buffer with respect to channels.
func (s {{ .Name }}) Slice(start, end int) {{ .Interface }} {
	start = BufferIndex(s.Channels(), 0, start)
	end = BufferIndex(s.Channels(), 0, end)
	s.buffer = s.buffer[start:end]
	return s
}

// Read{{ .Name }} reads values from the buffer into provided slice.
// Returns number of samples read per channel.
func Read{{ .Name }}(src {{ .Interface }}, dst []{{ .Builtin }}) int {
	length := min(src.Len(), len(dst))
	for i := 0; i < length; i++ {
		dst[i] = {{if eq .Interface "Floating"}}{{ .Builtin }}(src.Sample(i)){{else}}{{ .Builtin }}({{ .MaxBitDepth }}.{{ .Interface }}Value(src.Sample(i))){{end}}
	}
	return ChannelLength(length, src.Channels())
}

// ReadStriped{{ .Name }} reads values from the buffer into provided slice. The
// length of provided slice must be equal to the number of channels,
// otherwise function will panic. Nested slices can be nil, no values for
// that channel will be read. Returns a number of samples read for the
// longest channel.
func ReadStriped{{ .Name }}(src {{ .Interface }}, dst [][]{{ .Builtin }}) (read int) {
	mustSameChannels(src.Channels(), len(dst))
	for c := 0; c < src.Channels(); c++ {
		length := min(len(dst[c]), src.Length())
		if length > read {
			read = length
		}
		for i := 0; i < length; i++ {
			dst[c][i] = {{if eq .Interface "Floating"}}{{ .Builtin }}(src.Sample(BufferIndex(src.Channels(), c, i))){{else}}{{ .Builtin }}({{ .MaxBitDepth }}.{{ .Interface }}Value(src.Sample(BufferIndex(src.Channels(), c, i)))){{end}}
		}
	}
	return
}

// Write{{ .Name }} writes values from provided slice into the buffer.
// Returns a number of samples written per channel.
func Write{{ .Name }}(src []{{ .Builtin }}, dst {{ .Interface }}) int {
	length := min(dst.Len(), len(src))
	for i := 0; i < length; i++ {
		dst.SetSample(i, {{ .SampleType }}(src[i]))
	}
	return ChannelLength(length, dst.Channels())
}

// WriteStriped{{ .Name }} writes values from provided slice into the buffer.
// The length of provided slice must be equal to the number of channels,
// otherwise function will panic. Nested slices can be nil, zero values for
// that channel will be written. Returns a number of samples written for
// the longest channel.
func WriteStriped{{ .Name }}(src [][]{{ .Builtin }}, dst {{ .Interface }}) (written int) {
	mustSameChannels(dst.Channels(), len(src))
	// determine the length of longest nested slice
	for i := range src {
		if len(src[i]) > written {
			written = len(src[i])
		}
	}
	// limit a number of writes to the length of the buffer
	written = min(written, dst.Length())
	for c := 0; c < dst.Channels(); c++ {
		for i := 0; i < written; i++ {
			if i < len(src[c]) {
				dst.SetSample(BufferIndex(dst.Channels(), c, i), {{ .SampleType }}(src[c][i]))
			} else {
				dst.SetSample(BufferIndex(dst.Channels(), c, i), 0)
			}
		}
	}
	return
}{{end}}

{{define "tests"}}package signal_test

// Code generated by go generate; DO NOT EDIT.
// This file was generated by robots at
// {{ .Timestamp }}

import (
	"testing"

	"pipelined.dev/signal"
)

func Test{{ .Name }}(t *testing.T) {
	t.Run("{{ .Builtin }}", func() func(t *testing.T) {
		input := signal.Allocator{
			Channels: 3,
			Capacity: 3,
			Length:   3,
		}.{{ .Name }}({{if ne .Interface "Floating"}}signal.{{ .MaxBitDepth }}{{end}})
		signal.WriteStriped{{ .Name }}(
			[][]{{ .Builtin }}{
				{},
				{1, 2, 3},
				{11, 12, 13, 14},
			},
			input,
		)
		return testOk(
			signal.Allocator{
				Channels: 3,
				Capacity: 2,
			}.{{ .Name }}({{if ne .Interface "Floating"}}signal.{{ .MaxBitDepth }}{{end}}).Append(input.Slice(1, 3)),
			expected{
				length:   2,
				capacity: 2,
				data: [][]{{ .Builtin }}{
					{0, 0},
					{2, 3},
					{12, 13},
				},
			},
		)
	}())
}
{{end}}